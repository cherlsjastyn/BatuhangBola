<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>BATUHANG BOLA</title>
  <link href="https://fonts.googleapis.com/css2?family=Pacifico&family=Raleway:wght@300;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css" />
    <style>
    :root {
  --primary: #FF6B35;
  --secondary: #2F8B3A;
  --accent: #F7CB15;
  --dark: #2D3047;
  --light: #F8F4E3;
  --panel: rgba(255, 255, 255, 0.15);
  --shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
  --transition: all 0.3s ease;
  --bg: #f7b36d;
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html, body {
  margin: 0;
  padding: 0;
  height: 100%;
  font-family: 'Raleway', sans-serif;
  background: linear-gradient(135deg, var(--primary) 0%, #ff8c42 100%);
  color: var(--light);
  overflow: hidden;
}

canvas {
  display: block;
  width: 100vw;
  height: 100vh;
  background: linear-gradient(#7cc576, #5fb25b);
}

/* Decorative background elements */
.bg-bubbles {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 1;
  pointer-events: none;
}

.bg-bubbles li {
  position: absolute;
  list-style: none;
  display: block;
  width: 40px;
  height: 40px;
  background-color: rgba(255, 255, 255, 0.15);
  bottom: -160px;
  border-radius: 50%;
  animation: square 25s infinite;
  transition-timing-function: linear;
}

.bg-bubbles li:nth-child(1) {
  left: 10%;
  animation-delay: 0s;
  width: 80px;
  height: 80px;
}

.bg-bubbles li:nth-child(2) {
  left: 20%;
  animation-delay: 2s;
  animation-duration: 17s;
  width: 60px;
  height: 60px;
}

.bg-bubbles li:nth-child(3) {
  left: 25%;
  animation-delay: 4s;
}

.bg-bubbles li:nth-child(4) {
  left: 40%;
  animation-delay: 0s;
  animation-duration: 22s;
  width: 100px;
  height: 100px;
}

.bg-bubbles li:nth-child(5) {
  left: 70%;
  animation-delay: 3s;
}

.bg-bubbles li:nth-child(6) {
  left: 80%;
  animation-delay: 2s;
  width: 120px;
  height: 120px;
}

.bg-bubbles li:nth-child(7) {
  left: 32%;
  animation-delay: 6s;
  width: 70px;
  height: 70px;
}

.bg-bubbles li:nth-child(8) {
  left: 55%;
  animation-delay: 8s;
  animation-duration: 18s;
  width: 50px;
  height: 50px;
}

.bg-bubbles li:nth-child(9) {
  left: 25%;
  animation-delay: 9s;
  animation-duration: 20s;
  width: 30px;
  height: 30px;
}

.bg-bubbles li:nth-child(10) {
  left: 90%;
  animation-delay: 11s;
  width: 90px;
  height: 90px;
}

@keyframes square {
  0% {
    transform: translateY(0) rotate(0deg);
    opacity: 0.5;
    border-radius: 50%;
  }
  100% {
    transform: translateY(-1000px) rotate(720deg);
    opacity: 0;
    border-radius: 50%;
  }
}

/* Menu Styling */
.menu {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  background: var(--panel);
  backdrop-filter: blur(10px);
  padding: 32px;
  border-radius: 20px;
  box-shadow: var(--shadow);
  min-width: 400px;
  text-align: center;
  z-index: 50;
  border: 1px solid rgba(255, 255, 255, 0.2);
}

.menu h1 {
  font-family: 'Pacifico', cursive;
  color: var(--accent);
  margin: 0 0 24px;
  font-size: 48px;
  text-shadow: 3px 3px 10px rgba(0, 0, 0, 0.3);
}

.menu label {
  display: block;
  margin-bottom: 8px;
  font-weight: 700;
  text-align: left;
  padding-left: 8px;
  font-size: 18px;
  color: #fff;
  text-shadow: 1px 1px 4px rgba(0,0,0,0.6);
}

.menu input, .menu select {
  padding: 12px 16px;
  border-radius: 10px;
  border: 2px solid rgba(255, 255, 255, 0.2);
  margin: 8px 0 16px;
  width: 100%;
  background: rgba(255, 255, 255, 0.9);
  font-family: 'Raleway', sans-serif;
  font-size: 16px;
  transition: var(--transition);
}

.menu input:focus, .menu select:focus {
  outline: none;
  border-color: var(--accent);
  box-shadow: 0 0 0 3px rgba(247, 203, 21, 0.3);
}

/* Enhanced Button Styles */
button {
  background: linear-gradient(to bottom, var(--secondary), #2a7a34);
  color: white;
  border: none;
  border-radius: 12px;
  padding: 14px 28px;
  font-size: 18px;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.3s ease;
  font-family: 'Raleway', sans-serif;
  text-align: center;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2),
              inset 0 1px 1px rgba(255, 255, 255, 0.3);
  position: relative;
  overflow: hidden;
  margin: 8px 0;
}

button::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, 
              transparent, 
              rgba(255, 255, 255, 0.2), 
              transparent);
  transition: left 0.5s ease;
}

button:hover {
  transform: translateY(-3px);
  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25),
              inset 0 1px 1px rgba(255, 255, 255, 0.4);
}

button:hover::before {
  left: 100%;
}

button:active {
  transform: translateY(1px);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2),
              inset 0 1px 1px rgba(255, 255, 255, 0.2);
}

button:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(47, 139, 58, 0.4);
}

/* Specific button variants */
button.big {
  padding: 16px 32px;
  font-size: 20px;
  border-radius: 14px;
  width: 100%;
}

button.small {
  padding: 10px 20px;
  font-size: 16px;
  border-radius: 10px;
}

button.modeBtn {
  background: green;
  border: 2px solid var(--dark);
  color: var(--light);
  box-shadow: none;
}

button.modeBtn.active {
  background: var(--dark);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2),
              inset 0 1px 1px rgba(255, 255, 255, 0.3);
}

button.modeBtn:hover {
  background: rgba(45, 48, 71, 0.5);
}

/* Modal buttons */
#closeMechanics, #closeLeaderboard {
  background: linear-gradient(to bottom, var(--accent), #e6b413);
  color: var(--dark);
  font-weight: 700;
}

#closeMechanics:hover, #closeLeaderboard:hover {
  background: linear-gradient(to bottom, #f8d747, #dfab0c);
}

#restartBtn {
  background: linear-gradient(to bottom, var(--secondary), #2a7a34);
}

#restartBtn:hover {
  background: linear-gradient(to bottom, #3aa948, #268032);
}

#menuBtn {
  background: linear-gradient(to bottom, var(--primary), #e55a2a);
}

#menuBtn:hover {
  background: linear-gradient(to bottom, #ff7d4d, #d45328);
}

/* Disabled state */
button:disabled {
  background: #95a5a6;
  cursor: not-allowed;
  transform: none;
  box-shadow: none;
}

button:disabled:hover::before {
  left: -100%;
}

.section {
  margin-top: 20px;
  text-align: left;
}

.hidden {
  display: none !important;
}

/* Page backgrounds */
#nameEntryPage, 
#mainMenuPage, 
#gameOptionsPage {
  background: url("back.jpg") no-repeat center center;
  background-size: cover;
}

/* HUD Styling */
.hud {
  position: absolute;
  left: 20px;
  top: 20px;
  z-index: 40;
  color: white;
  display: flex;
  gap: 15px;
  align-items: flex-start;
  font-weight: 600;
  flex-wrap: wrap;
}

.scoreboard, .turnLabel, .controlsLegend {
  background: var(--panel);
  backdrop-filter: blur(5px);
  padding: 12px 18px;
  border-radius: 10px;
  text-shadow: 1px 1px 3px #000;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.controlsLegend {
  max-width: 420px;
}

/* Modal Styling */
.modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2000;
  backdrop-filter: blur(5px);
}

.modal.hidden {
  display: none;
}

.modal-content {
  background: linear-gradient(135deg, #4e54c8 0%, #8f94fb 100%);
  padding: 30px;
  border-radius: 20px;
  text-align: center;
  max-width: 450px;
  width: 90%;
  box-shadow: var(--shadow);
  color: white;
  position: relative;
  overflow: hidden;
}

.modal-content::before {
  content: '';
  position: absolute;
  top: -50%;
  left: -50%;
  width: 200%;
  height: 200%;
  background: radial-gradient(circle, rgba(255, 255, 255, 0.1) 0%, transparent 60%);
  transform: rotate(45deg);
  pointer-events: none;
}

.modal-content h2 {
  margin-top: 0;
  margin-bottom: 20px;
  font-size: 32px;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
}

.modal-content p {
  font-size: 18px;
  margin-bottom: 25px;
}

.modal-buttons {
  margin-top: 25px;
  display: flex;
  gap: 15px;
  justify-content: center;
}

.modal-buttons button {
  padding: 12px 24px;
  font-size: 16px;
  font-weight: 600;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  transition: var(--transition);
  min-width: 120px;
}

/* Mechanics and Leaderboard modals */
#mechanicsModal, #leaderboardModal {
   position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: linear-gradient(to bottom, #4e54c8, #8f94fb);
  padding: 30px;
  border-radius: 20px;
  z-index: 2000;
  max-width: 500px;
  width: 90%;
  max-height: 80vh;
  display: flex;
  flex-direction: column; /* ensures vertical layout */
  box-shadow: var(--shadow);
  color: white;
  overflow-y: auto;
}
#mechanicsModal h3, #leaderboardModal h3 {
   margin: 0 0 20px;
  text-align: center;
  font-size: 28px;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
}

#mechanicsContent, #leaderboardContent {
 flex: 1; /* makes content expand naturally */
  margin-bottom: 20px;
  line-height: 1.6;
  font-size: 16px;
  overflow-y: auto;
}


#closeMechanics {
  margin-top: auto; /* pushes button to the bottom */
  padding: 10px 20px;
  background: linear-gradient(to bottom, var(--accent), #e6b413);
  color: var(--dark);
  border: none;
  border-radius: 8px;
  font-weight: bold;
  cursor: pointer;
  transition: var(--transition);
}

#closeMechanics:hover {
  background: linear-gradient(to bottom, #f8d747, #dfab0c);
}

/* Leaderboard table styles */
.leaderboard-table {
  width: 100%;
  border-collapse: collapse;
  margin: 15px 0;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 8px;
  overflow: hidden;
}

.leaderboard-table th,
.leaderboard-table td {
  padding: 10px;
  text-align: center;
  border-bottom: 1px solid rgba(255, 255, 255, 0.2);
}

.leaderboard-table th {
  background: rgba(0, 0, 0, 0.2);
  font-weight: 600;
}

.leaderboard-table tr:last-child td {
  border-bottom: none;
}

.leaderboard-table tr:hover {
  background: rgba(255, 255, 255, 0.05);
}

#leaderboardTable {
  width: 100%;
  border-collapse: collapse;
  margin: 15px 0;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 8px;
  overflow: hidden;
}

#leaderboardTable th, #leaderboardTable td {
  padding: 10px;
  text-align: center;
  border-bottom: 1px solid rgba(255, 255, 255, 0.2);
}

#leaderboardTable th {
  background: rgba(0, 0, 0, 0.2);
  font-weight: 600;
}

#leaderboardTable tr:last-child td {
  border-bottom: none;
}

#leaderboardTable tr:hover {
  background: rgba(255, 255, 255, 0.05);
}

.no-records, .error {
  text-align: center;
  padding: 20px;
  color: #fff;
  text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
}

.error {
  color: #ff6b6b;
  font-weight: 800;
  margin-top: 6px;
  font-size: 16px;
  text-align: center;
  text-shadow: 1px 1px 4px rgba(0,0,0,0.7);
}

/* Throw guide line */
.guide-line {
  position: absolute;
  background: rgba(255, 255, 255, 0.5);
  pointer-events: none;
  z-index: 30;
}

/* Icon enhancements */
.icon-text {
  display: flex;
  align-items: center;
  gap: 8px;
}

/* Animation for page transitions */
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

/* Page container styles */
.page {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 100;
  animation: fadeIn 0.5s ease;
}

.page.hidden {
  display: none;
}

/* Responsive design */
@media (max-width: 768px) {
  .menu {
    width: 90vw;
    min-width: unset;
    padding: 24px;
  }
  
  .menu h1 {
    font-size: 36px;
  }
  
  .hud {
    flex-direction: column;
    align-items: flex-start;
    gap: 10px;
  }
  
  .controlsLegend {
    display: none;
  }
  
  #mechanicsModal, #leaderboardModal {
    width: 95%;
    padding: 20px;
  }
  
  .modal-buttons {
    flex-direction: column;
    gap: 10px;
  }
  
  .modal-buttons button {
    width: 100%;
  }
  
  .leaderboard-table, #leaderboardTable {
    font-size: 12px;
  }
  
  .leaderboard-table th,
  .leaderboard-table td,
  #leaderboardTable th,
  #leaderboardTable td {
    padding: 6px;
  }
}

@media (max-width: 520px) {
  .menu {
    width: 92vw;
    padding: 16px;
  }
  
  .menu h1 {
    font-size: 32px;
  }
  
  button {
    padding: 12px 20px;
    font-size: 16px;
  }
  
  .modal-content {
    padding: 20px;
  }
  
  .modal-content h2 {
    font-size: 24px;
  }
}
.connection-status { padding: 5px; margin: 5px; }
        .connected { background: green; color: white; }
        .disconnected { background: red; color: white; }
        .current-player { background-color: #e6f7ff; }
        #highScoreNotification {
            background: gold;
            padding: 10px;
            margin: 10px 0;
            display: none;
        }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <!-- Page 1: Name Entry -->
<div id="nameEntryPage" class="page">
  <div class="menu">
    <h1>BATUHANG BOLA</h1>
    <label>Enter Your Name</label>
    <input id="playerName" placeholder="Your name" required/>

    <!-- ⚠️ Error message (hidden by default) -->
    <p id="nameError" class="error hidden">⚠️ Please enter your name</p>

    <button id="btnContinue" class="big">Continue</button>
  </div>
</div>

  
  <!-- Page 2: Main Menu -->
  <div id="mainMenuPage" class="page hidden">
    <div class="menu">
      <h1>BATUHANG BOLA</h1>
      <button id="btnStartGame" class="big">Start Game</button>
      <button id="btnMechanics">Mechanics</button>
      <button id="btnLeaderboard">Leaderboard</button>
    </div>
  </div>
  
  <!-- Page 3: Game Options -->
  <div id="gameOptionsPage" class="page hidden">
    <div class="menu">
      <h1>Game Options</h1>
      <div class="section">
        <label>Mode</label>
        <div>
          <button id="btnModeThrower" class="modeBtn">Thrower</button>
          <button id="btnModeDodger" class="modeBtn">Dodger</button>
        </div>
      </div>
      <div id="throwerOptions" class="section hidden">
        <label>How many human throwers?</label>
        <select id="selectThrowerCount">
          <option value="1">1 human (+1 AI teammate)</option>
          <option value="2">2 humans (no AI teammate)</option>
        </select>
      </div>
      <div id="dodgerOptions" class="section hidden">
        <label>How many human dodgers?</label>
        <select id="selectDodgerCount">
          <option value="1">1</option>
          <option value="2">2</option>
          <option value="3">3</option>
          <option value="4">4</option>
        </select>
      </div>
      <div class="section">
        <label>Difficulty</label>
        <select id="selectDifficulty">
          <option value="easy">easy</option>
          <option value="medium">medium</option>
          <option value="hard">hard</option>
        </select>
      </div>
      <div style="margin-top:12px">
        <button id="btnPlay" class="big">Play</button>
      </div>
      <div style="margin-top:12px">
        <button id="btnBackToMenu">Back to Menu</button>
      </div>
    </div>
  </div>
  
  <!-- HUD (only visible during gameplay) -->
  <div id="hud" class="hud hidden">
    <div id="scoreboard" class="scoreboard">Dodgers Remaining: 0</div>
    <div id="turnLabel" class="turnLabel">Turn: —</div>
    <div id="controlsLegend" class="controlsLegend"></div>
    <button id="btnExit" class="small">Exit to Menu</button>
  </div>
  
  <!-- Modals -->
  <div id="mechanicsModal" class="modal hidden">
    <h3>Mechanics</h3>
    <div id="mechanicsContent"></div>
    <button id="closeMechanics">Close</button>
  </div>
  
  <div id="leaderboardModal" class="modal hidden">
    <h3>Leaderboard</h3>
    <div id="leaderboardContent"></div>
    <button id="closeLeaderboard">Close</button>
  </div>
  
  <div id="gameOverModal" class="modal hidden">
    <div class="modal-content">
      <h2>Game Over</h2>
      <p id="finalScoreText">Your score: 0</p>
      <div class="modal-buttons">
        <button id="restartBtn">Restart</button>
        <button id="menuBtn">Main Menu</button>
      </div>
    </div>
  </div>
    <div id="gameScreen" style="display: none;">
        <div id="connectionStatus" class="connection-status">Status: disconnected</div>
        <div id="playerCount">Online Players: 0</div>
        <div id="playerInfo"></div>
        
        <div id="highScoreNotification"></div>
  <script>
    /* game.js - Complete restructuring for multi-page flow and improved gameplay */
(() => {
  // --- Canvas / basic settings ---
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  let W = window.innerWidth, H = window.innerHeight;

  function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resize);
  resize();

  // --- Page Elements ---
  const nameEntryPage = document.getElementById('nameEntryPage');
  const mainMenuPage = document.getElementById('mainMenuPage');
  const gameOptionsPage = document.getElementById('gameOptionsPage');
  const playerNameInput = document.getElementById('playerName');
  const btnContinue = document.getElementById('btnContinue');
  const btnStartGame = document.getElementById('btnStartGame');
  const btnMechanics = document.getElementById('btnMechanics');
  const btnLeaderboard = document.getElementById('btnLeaderboard');
  const btnModeThrower = document.getElementById('btnModeThrower');
  const btnModeDodger = document.getElementById('btnModeDodger');
  const throwerOptions = document.getElementById('throwerOptions');
  const dodgerOptions = document.getElementById('dodgerOptions');
  const selectThrowerCount = document.getElementById('selectThrowerCount');
  const selectDodgerCount = document.getElementById('selectDodgerCount');
  const selectDifficulty = document.getElementById('selectDifficulty');
  const btnPlay = document.getElementById('btnPlay');
  const btnBackToMenu = document.getElementById('btnBackToMenu');
  
  // HUD elements
  const hud = document.getElementById('hud');
  const scoreboardEl = document.getElementById('scoreboard');
  const turnLabel = document.getElementById('turnLabel');
  const controlsLegend = document.getElementById('controlsLegend');
  const btnExit = document.getElementById('btnExit');
  
  // Modal elements
  const mechanicsModal = document.getElementById('mechanicsModal');
  const mechanicsContent = document.getElementById('mechanicsContent');
  const closeMechanics = document.getElementById('closeMechanics');
  const leaderboardModal = document.getElementById('leaderboardModal');
  const leaderboardContent = document.getElementById('leaderboardContent');
  const closeLeaderboard = document.getElementById('closeLeaderboard');
  const gameOverModal = document.getElementById('gameOverModal');
  const finalScoreText = document.getElementById('finalScoreText');
  const restartBtn = document.getElementById('restartBtn');
  const menuBtn = document.getElementById('menuBtn');

  // Ability UI
  const abilityBar = document.createElement('div');
  abilityBar.id = 'abilityBar';
  abilityBar.className = 'ability-bar hidden';
  abilityBar.innerHTML = `
    <div class="ability-group">
      <button id="ability1" class="ability-btn" disabled>Ability 1</button>
      <span class="ability-count">2</span>
    </div>
    <div class="ability-group">
      <button id="ability2" class="ability-btn" disabled>Ability 2</button>
      <span class="ability-count">2</span>
    </div>
  `;
  document.body.appendChild(abilityBar);

  // --- Navigation Functions ---
  function showPage(page) {
    // Hide all pages
    nameEntryPage.classList.add('hidden');
    mainMenuPage.classList.add('hidden');
    gameOptionsPage.classList.add('hidden');
    hud.classList.add('hidden');
    
    // Show the requested page
    page.classList.remove('hidden');
  }

  // Initial page
  showPage(nameEntryPage);

  // Continue button - go to main menu
 document.getElementById("btnContinue").addEventListener("click", () => {
  const playerName = document.getElementById("playerName").value.trim();
  const errorEl = document.getElementById("nameError");

  if (!playerName) {
  errorEl.classList.remove("hidden");
  document.getElementById("playerName").classList.add("error-input"); // glow red
  return;
}

errorEl.classList.add("hidden");
document.getElementById("playerName").classList.remove("error-input"); // remove glow

  errorEl.classList.add("hidden");        // hide error if filled
  document.getElementById("nameEntryPage").classList.add("hidden");
  document.getElementById("mainMenuPage").classList.remove("hidden");
});

  // Start Game button - go to game options
  btnStartGame.addEventListener('click', () => {
    showPage(gameOptionsPage);
  });

  // Back to menu button
  btnBackToMenu.addEventListener('click', () => {
    showPage(mainMenuPage);
  });

  // Mode selection
  btnModeThrower.addEventListener('click', () => {
    mode = 'thrower';
    btnModeThrower.classList.add('active');
    btnModeDodger.classList.remove('active');
    throwerOptions.classList.remove('hidden');
    dodgerOptions.classList.add('hidden');
  });

  btnModeDodger.addEventListener('click', () => {
    mode = 'dodger';
    btnModeDodger.classList.add('active');
    btnModeThrower.classList.remove('active');
    dodgerOptions.classList.remove('hidden');
    throwerOptions.classList.add('hidden');
  });

  // Set default mode
  btnModeThrower.click();

  // Modal controls
  closeMechanics.addEventListener('click', () => mechanicsModal.classList.add('hidden'));
  closeLeaderboard.addEventListener('click', () => leaderboardModal.classList.add('hidden'));

  // Mechanics button
  btnMechanics.addEventListener('click', async () => {
    try {
      const res = await fetch('/api/mechanics');
      const rows = await res.json();
      mechanicsContent.innerHTML = rows.map(r => `<h4>${r.title}</h4><p>${r.content}</p>`).join('');
      mechanicsModal.classList.remove('hidden');
    } catch (e) {
      alert('Mechanics load error');
    }
  });

  // Leaderboard button
btnLeaderboard.addEventListener('click', async () => {
  try {
    const role = 'dodger'; // or make this dynamic based on game mode
    const difficulty = selectDifficulty.value || 'easy';
    const limit = 10;
    
    const response = await fetch(`/api/leaderboard?role=${role}&difficulty=${difficulty}&limit=${limit}`);
    
    if (!response.ok) {
      throw new Error(`Server returned ${response.status}: ${response.statusText}`);
    }
    
    const rows = await response.json();
    
    if (rows.length === 0) {
      leaderboardContent.innerHTML = '<div class="no-records">No records found. Play some games first!</div>';
    } else {
      leaderboardContent.innerHTML = `
        <table class="leaderboard-table">
          <thead>
            <tr>
              <th>Rank</th>
              <th>Name</th>
              <th>Score</th>
              <th>Games</th>
              <th>Wins</th>
            </tr>
          </thead>
          <tbody>
            ${rows.map((player, index) => `
              <tr>
                <td>${index + 1}</td>
                <td>${player.player_name || player.name}</td> <!-- UPDATE THIS LINE -->
                <td>${player.total_score}</td>
                <td>${player.games_played}</td>
                <td>${player.wins}</td>
              </tr>
            `).join('')}
          </tbody>
        </table>
      `;
    }
    
    leaderboardModal.classList.remove('hidden');
  } catch (e) {
    console.error('Leaderboard load error:', e);
    leaderboardContent.innerHTML = `<div class="error">Error loading leaderboard: ${e.message}</div>`;
    leaderboardModal.classList.remove('hidden');
  }
});

  // --- Game State & Entities ---
  let mode = null;
  let difficulty = 'easy';
  let humanThrowerCount = 1;
  let humanDodgerCount = 1;
  let localPlayer = null;
  let playerScore = 0;
  
  // Teams
  let throwers = [];
  let dodgers = [];
  let activeBall = null;
  let ballIdCounter = 0;
  
  // Turn & flow
  let currentThrowerIndex = 0;
  let ballInFlight = false;
  let gameRunning = false;
  
  // Throwing guide
  let throwGuide = {
    visible: false,
    startX: 0,
    startY: 0,
    endX: 0,
    endY: 0
  };

  // Obstacles
  let obstacles = [];

  // Ability keys
  const ABILITY_KEYS = {
    player1: { ability1: 'KeyZ', ability2: 'KeyX' },
    player2: { ability1: 'KeyN', ability2: 'KeyM' },
    player3: { ability1: 'BracketLeft', ability2: 'BracketRight' },
    player4: { ability1: 'Numpad0', ability2: 'Numpad1' }
  };

  // Difficulty settings
  const DIFF = {
    easy: { react: 900, success: 0.45, speed: 0.8 },
    medium: { react: 500, success: 0.7, speed: 1.0, obstacles: true },
    hard: { react: 250, success: 0.9, speed: 1.0, obstacles: true, fastBalls: true } // Removed dodger speed boost
  };

  // Controls mapping - Updated for new thrower controls
  const controls = {
    thrower1: { aimUp:'KeyW', aimDown:'KeyS', left:'KeyA', right:'KeyD', throw:'Space' },
    thrower2: { aimUp:'ArrowUp', aimDown:'ArrowDown', left:'ArrowLeft', right:'ArrowRight', throw:'Numpad5' },
    dodgers: [
      { up:'KeyW', down:'KeyS', left:'KeyA', right:'KeyD' },
      { up:'KeyI', down:'KeyK', left:'KeyJ', right:'KeyL' },
      { up:'ArrowUp', down:'ArrowDown', left:'ArrowLeft', right:'ArrowRight' },
      { up:'Numpad8', down:'Numpad5', left:'Numpad4', right:'Numpad6' }
    ]
  };

  // Keyboard state
  const keyState = {};
  window.addEventListener('keydown', e => { keyState[e.code] = true; });
  window.addEventListener('keyup', e => { keyState[e.code] = false; });

  // --- Obstacle Class ---
  class Obstacle {
    constructor(x, y, width, height, type) {
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      this.type = type; // 'static' or 'moving'
      this.speed = type === 'moving' ? (Math.random() * 2 + 1) : 0;
      this.direction = Math.random() > 0.5 ? 1 : -1;
    }
    
    update(dt) {
      if (this.type === 'moving') {
        this.x += this.speed * this.direction * (dt / 1000);
        
        // Reverse direction at boundaries
        if (this.x < 0 || this.x + this.width > W) {
          this.direction *= -1;
        }
      }
    }
    
    draw() {
      ctx.save();
      ctx.fillStyle = 'rgba(100, 100, 100, 0.7)';
      ctx.fillRect(this.x, this.y, this.width, this.height);
      
      // Add some visual details
      ctx.strokeStyle = 'rgba(50, 50, 50, 0.9)';
      ctx.lineWidth = 2;
      ctx.strokeRect(this.x, this.y, this.width, this.height);
      
      ctx.restore();
    }
  }

  // --- Ability Class ---
  class Ability {
    constructor(player, type, key, uses = 2) {
      this.player = player;
      this.type = type;
      this.key = key;
      this.uses = uses;
      this.maxUses = uses;
      this.cooldown = 0;
    }
    
    activate() {
      if (this.uses <= 0 || this.cooldown > 0) return false;
      
      this.uses--;
      this.cooldown = 180; // 3 seconds at 60fps
      
      // Apply ability effect based on type
      switch(this.type) {
        case 'speedBoost':
          this.player.speedMultiplier = 1.8;
          setTimeout(() => {
            this.player.speedMultiplier = 1;
          }, 3000);
          break;
          
        case 'temporaryShield':
          this.player.shielded = true;
          setTimeout(() => {
            this.player.shielded = false;
          }, 3000);
          break;
          
        case 'freeze':
          // Freeze all opponents for 2 seconds
          if (this.player.isThrower) {
            dodgers.forEach(d => {
              d.frozen = true;
              setTimeout(() => {
                d.frozen = false;
              }, 2000);
            });
          } else {
            throwers.forEach(t => {
              t.frozen = true;
              setTimeout(() => {
                t.frozen = false;
              }, 2000);
            });
          }
          break;
          
        case 'rapidFire':
          if (this.player.isThrower) {
            this.player.rapidFire = true;
            setTimeout(() => {
              this.player.rapidFire = false;
            }, 3000);
          }
          break;
      }
      
      return true;
    }
    
    update() {
      if (this.cooldown > 0) {
        this.cooldown--;
      }
    }
  }

  // --- Entity Creation Functions ---
  function createHumanThrower(name, controlSet, color, isTop, playerIndex) {
    const player = {
      id: `human-throw-${Math.random().toString(36).slice(2,6)}`,
      name,
      x: W * 0.5,
      y: isTop ? 60 : H - 60,
      isHuman: true,
      control: controlSet,
      color,
      alive: true,
      speedMultiplier: 1,
      isTop: isTop,
      isThrower: true,
      aimAngle: isTop ? Math.PI/2 : -Math.PI/2,
      abilities: [],
      shielded: false,
      frozen: false,
      rapidFire: false
    };
    
    // Add abilities based on player index
    if (playerIndex === 0) {
      player.abilities = [
        new Ability(player, 'rapidFire', ABILITY_KEYS.player1.ability1),
        new Ability(player, 'freeze', ABILITY_KEYS.player1.ability2)
      ];
    } else if (playerIndex === 1) {
      player.abilities = [
        new Ability(player, 'rapidFire', ABILITY_KEYS.player2.ability1),
        new Ability(player, 'freeze', ABILITY_KEYS.player2.ability2)
      ];
    }
    
    return player;
  }

  function createAIThrower(name, color, isTop) {
    return {
      id: `ai-throw-${Math.random().toString(36).slice(2,6)}`,
      name,
      x: W * 0.5,
      y: isTop ? 60 : H - 60,
      isHuman: false,
      color,
      alive: true,
      speedMultiplier: 1,
      isTop: isTop,
      isThrower: true,
      direction: Math.random() > 0.5 ? 1 : -1,
      rapidFire: false
    };
  }

  function createHumanDodger(name, controlSet, color, startX, playerIndex) {
    // Calculate middle area between throwers
    const topThrowerY = throwers.find(t => t.isTop)?.y || 60;
    const bottomThrowerY = throwers.find(t => !t.isTop)?.y || H - 60;
    const middleY = topThrowerY + (bottomThrowerY - topThrowerY) / 2;
    
    const player = {
      id: `human-dod-${Math.random().toString(36).slice(2,6)}`,
      name,
      x: startX,
      y: middleY, // Start in the middle of the extended area
      isHuman: true,
      control: controlSet,
      color,
      alive: true,
      speedMultiplier: 1,
      lastReact: 0,
      scoredOnThisBall: false,
      isThrower: false,
      abilities: [],
      shielded: false,
      frozen: false
    };
    
    // Add abilities based on player index
    if (playerIndex === 0) {
      player.abilities = [
        new Ability(player, 'speedBoost', ABILITY_KEYS.player1.ability1),
        new Ability(player, 'temporaryShield', ABILITY_KEYS.player1.ability2)
      ];
    } else if (playerIndex === 1) {
      player.abilities = [
        new Ability(player, 'speedBoost', ABILITY_KEYS.player2.ability1),
        new Ability(player, 'temporaryShield', ABILITY_KEYS.player2.ability2)
      ];
    } else if (playerIndex === 2) {
      player.abilities = [
        new Ability(player, 'speedBoost', ABILITY_KEYS.player3.ability1),
        new Ability(player, 'temporaryShield', ABILITY_KEYS.player3.ability2)
      ];
    } else if (playerIndex === 3) {
      player.abilities = [
        new Ability(player, 'speedBoost', ABILITY_KEYS.player4.ability1),
        new Ability(player, 'temporaryShield', ABILITY_KEYS.player4.ability2)
      ];
    }
    
    return player;
  }

  function createAIDodger(name, color, startX) {
    // Calculate middle area between throwers
    const topThrowerY = throwers.find(t => t.isTop)?.y || 60;
    const bottomThrowerY = throwers.find(t => !t.isTop)?.y || H - 60;
    const middleY = topThrowerY + (bottomThrowerY - topThrowerY) / 2;
    
    return {
      id: `ai-dod-${Math.random().toString(36).slice(2,6)}`,
      name,
      x: startX,
      y: middleY, // Start in the middle of the extended area
      isHuman: false,
      color,
      alive: true,
      speedMultiplier: 1,
      lastReact: 0,
      scoredOnThisBall: false,
      isThrower: false,
      shielded: false,
      frozen: false
    };
  }


  // --- Drawing Functions ---
  function drawHuman(p, isThrower = false) {
    const x = p.x, y = p.y;
    ctx.save();
    
    // Draw shield if active
    if (p.shielded) {
      ctx.fillStyle = 'rgba(0, 150, 255, 0.2)';
      ctx.beginPath();
      ctx.arc(x, y, 30, 0, Math.PI*2);
      ctx.fill();
      
      ctx.strokeStyle = 'rgba(0, 150, 255, 0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(x, y, 30, 0, Math.PI*2);
      ctx.stroke();
    }
    
    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.12)';
    ctx.beginPath();
    ctx.ellipse(x, y + 30, 26, 10, 0, 0, Math.PI*2);
    ctx.fill();
    
    // Head
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(x, y-14, 12, 0, Math.PI*2);
    ctx.fill();
    
    // Body
    ctx.fillStyle = p.color || '#ff6b6b';
    ctx.fillRect(x-10, y-4, 20, 28);
    
    // Arms
    ctx.strokeStyle = '#222';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x-10,y+4);
    ctx.lineTo(x-22,y+8);
    ctx.moveTo(x+10,y+4);
    ctx.lineTo(x+22,y+8);
    ctx.stroke();
    
    // Legs
    ctx.beginPath();
    ctx.moveTo(x-6,y+24);
    ctx.lineTo(x-12,y+44);
    ctx.moveTo(x+6,y+24);
    ctx.lineTo(x+12,y+44);
    ctx.stroke();
    
    // Name label
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.font = '11px Raleway';
    ctx.textAlign = 'center';
    ctx.fillText(p.name || '', x, y-30);
    
    // Draw aim indicator for throwers
    if (isThrower && p.isHuman && p === throwers[currentThrowerIndex] && !ballInFlight) {
      const aimLength = 40;
      const aimX = x + Math.cos(p.aimAngle) * aimLength;
      const aimY = y + Math.sin(p.aimAngle) * aimLength;
      
      ctx.strokeStyle = 'rgba(255, 255, 0, 0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(aimX, aimY);
      ctx.stroke();
      
      // Draw aim circle
      ctx.fillStyle = 'rgba(255, 255, 0, 0.5)';
      ctx.beginPath();
      ctx.arc(aimX, aimY, 6, 0, Math.PI*2);
      ctx.fill();
    }
    
    ctx.restore();
  }

  function drawBall(b) {
    ctx.save();
    ctx.fillStyle = '#fdd835';
    ctx.beginPath();
    ctx.arc(b.x, b.y, 10, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  function drawCourt() {
    // Court markings
    ctx.strokeStyle = 'rgba(255,255,255,0.9)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(0, H/2);
    ctx.lineTo(W, H/2);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.arc(W/2, H/2, H*0.09, 0, Math.PI*2);
    ctx.stroke();
    
    // Extended dodger area (subtle background)
    const topThrowerY = throwers.find(t => t.isTop)?.y || 60;
    const bottomThrowerY = throwers.find(t => !t.isTop)?.y || H - 60;
    
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.fillRect(0, topThrowerY + 30, W, bottomThrowerY - topThrowerY - 60);
    
    // Boundary lines for extended area
    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
    ctx.setLineDash([5, 5]);
    ctx.beginPath();
    ctx.moveTo(0, topThrowerY + 40);
    ctx.lineTo(W, topThrowerY + 40);
    ctx.moveTo(0, bottomThrowerY - 40);
    ctx.lineTo(W, bottomThrowerY - 40);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // Draw obstacles
    obstacles.forEach(obstacle => obstacle.draw());
  }

  function drawThrowGuide() {
    if (!throwGuide.visible) return;
    
    ctx.save();
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 5]);
    ctx.beginPath();
    ctx.moveTo(throwGuide.startX, throwGuide.startY);
    ctx.lineTo(throwGuide.endX, throwGuide.endY);
    ctx.stroke();
    ctx.restore();
  }

  // --- Obstacle Generation ---
  function generateObstacles() {
    const obstacleCount = difficulty === 'medium' ? 2 : 4;
    const isThrowerMode = mode === 'thrower';
    
    for (let i = 0; i < obstacleCount; i++) {
      const width = 40 + Math.random() * 60;
      const height = 20 + Math.random() * 40;
      
      // Position obstacles in the middle area (dodger zone)
      let x, y;
      
      if (isThrowerMode) {
        // For thrower mode, place obstacles in the dodging area
        x = Math.random() * (W - width);
        y = H * 0.3 + Math.random() * (H * 0.4 - height);
      } else {
        // For dodger mode, place obstacles throughout the court
        x = Math.random() * (W - width);
        y = H * 0.2 + Math.random() * (H * 0.6 - height);
      }
      
      const type = difficulty === 'hard' && Math.random() > 0.5 ? 'moving' : 'static';
      obstacles.push(new Obstacle(x, y, width, height, type));
    }
  }

  // --- Ability UI ---
  function updateAbilityUI() {
    const abilityBar = document.getElementById('abilityBar');
    if (!abilityBar) return;
    
    // Show ability bar only for human players
    const humanPlayers = [...throwers, ...dodgers].filter(p => p.isHuman);
    if (humanPlayers.length > 0) {
      abilityBar.classList.remove('hidden');
      
      // For simplicity, just show abilities for the first human player
      const player = humanPlayers[0];
      
      if (player.abilities && player.abilities.length >= 2) {
        const ability1 = document.getElementById('ability1');
        const ability2 = document.getElementById('ability2');
        
        if (ability1 && ability2) {
          // Extract key name without "Key" prefix
          const key1 = player.abilities[0].key.replace('Key', '').replace('Numpad', 'Num');
          const key2 = player.abilities[1].key.replace('Key', '').replace('Numpad', 'Num');
          
          ability1.textContent = `Ability 1 (${key1})`;
          ability2.textContent = `Ability 2 (${key2})`;
          
          ability1.disabled = player.abilities[0].uses <= 0 || player.abilities[0].cooldown > 0;
          ability2.disabled = player.abilities[1].uses <= 0 || player.abilities[1].cooldown > 0;
          
          const counts = abilityBar.querySelectorAll('.ability-count');
          if (counts.length >= 2) {
            counts[0].textContent = player.abilities[0].uses;
            counts[1].textContent = player.abilities[1].uses;
          }
        }
      }
    } else {
      abilityBar.classList.add('hidden');
    }
  }

  // --- Team Setup ---
  function buildTeams() {
    throwers = [];
    dodgers = [];
    obstacles = []; // Clear previous obstacles
    difficulty = selectDifficulty.value || 'easy';
    
    // Add obstacles for medium and hard difficulties
    if (difficulty !== 'easy') {
      generateObstacles();
    }
    
    if (mode === 'thrower') {
      humanThrowerCount = Number(selectThrowerCount.value || 1);
      
      // Create human throwers on opposite sides
      if (humanThrowerCount >= 1) {
        throwers.push(createHumanThrower('You', controls.thrower1, '#4ac0e6', true, 0));
      }
      if (humanThrowerCount >= 2) {
        throwers.push(createHumanThrower('You 2', controls.thrower2, '#7fe36a', false, 1));
      }
      
      // Add AI teammates if needed
      if (humanThrowerCount === 1) {
        throwers.push(createAIThrower('AI-Thrower', '#f59b42', false));
      }
      
      // Position throwers
      throwers.forEach((t, i) => {
        t.x = W * (0.3 + 0.4 * (i % 2));
      });
      
      // Create AI dodgers
      for (let i = 0; i < 4; i++) {
        const sx = W * (0.25 + i * 0.15);
        dodgers.push(createAIDodger(`AI-Dodger-${i+1}`, '#ff6b6b', sx));
      }
    } else {
      // Dodger mode
      humanDodgerCount = Number(selectDodgerCount.value || 1);
      const orderColors = ['#4ac0e6','#7fe36a','#ffd86b','#c88cff'];
      
      // Create human and AI dodgers
      for (let i = 0; i < 4; i++) {
        const sx = W * (0.25 + i * 0.15);
        if (i < humanDodgerCount) {
          dodgers.push(createHumanDodger(`You${i+1}`, controls.dodgers[i], orderColors[i], sx, i));
        } else {
          dodgers.push(createAIDodger(`AI-Dodger-${i+1}`, '#ff7b7b', sx));
        }
      }
      
      // Create AI throwers on opposite sides
      throwers.push(createAIThrower('AI-T1', '#f59b42', true));
      throwers.push(createAIThrower('AI-T2', '#f59b42', false));
      
      throwers.forEach((t, i) => {
        t.x = W * (0.3 + 0.4 * (i % 2));
      });
    }
    
    // Set difficulty parameters for AI
    const dd = DIFF[difficulty];
    dodgers.forEach(d => {
      d.reactMs = dd.react;
      d.successProb = dd.success;
      d.speed = 1 * dd.speed; // Removed speed boost for dodgers in hard mode
    });
    
    // Reset game state
    currentThrowerIndex = 0;
    ballInFlight = false;
    activeBall = null;
    playerScore = 0;
    
    updateTurnLabel();
    updateControlsLegend();
    updateAbilityUI();
  }

  // --- Game Mechanics ---
  function updateTurnLabel() {
    if (!hud) return;
    const t = throwers[currentThrowerIndex];
    turnLabel.innerText = `Turn: ${t ? (t.isHuman ? 'Human' : t.name) : '-'}`;
  }

  function updateControlsLegend() {
    if (!hud) return;
    let txt = '';
    
    if (mode === 'thrower') {
      txt = 'Thrower controls — Player1: A/D to move, W/S to aim, Space to throw. Player2: Arrows to move/aim, Numpad5 to throw.';
    } else {
      txt = 'Dodger controls: D1 WASD, D2 IJKL, D3 Arrows, D4 Numpad 8/5/4/6';
    }
    
    controlsLegend.innerText = txt;
  }

  function startThrowGuide(thrower) {
    throwGuide.visible = true;
    throwGuide.startX = thrower.x;
    throwGuide.startY = thrower.y;
    throwGuide.endX = thrower.x + Math.cos(thrower.aimAngle) * 200;
    throwGuide.endY = thrower.y + Math.sin(thrower.aimAngle) * 200;
  }

  function updateThrowGuideFromAim(thrower) {
    if (!throwGuide.visible) return;
    
    throwGuide.endX = thrower.x + Math.cos(thrower.aimAngle) * 200;
    throwGuide.endY = thrower.y + Math.sin(thrower.aimAngle) * 200;
  }

  function executeThrow() {
    if (ballInFlight) return false;
    
    const thrower = throwers[currentThrowerIndex];
    if (!thrower || !thrower.alive || thrower.frozen) return false;
    
    // Calculate direction based on aim angle
    const dirX = Math.cos(thrower.aimAngle);
    const dirY = Math.sin(thrower.aimAngle);
    
    // Create ball with velocity
    const ballSpeed = (difficulty === 'hard' && mode === 'dodger') ? 500 : 400;
    const ball = {
      id: ++ballIdCounter,
      x: thrower.x,
      y: thrower.y,
      dirX,
      dirY,
      speed: ballSpeed,
      ownerIndex: currentThrowerIndex
    };
    
    activeBall = ball;
    ballInFlight = true;
    throwGuide.visible = false;
    
    // If in rapid fire mode, schedule next throw
    if (thrower.rapidFire) {
      setTimeout(() => {
        if (currentThrowerIndex === ball.ownerIndex && !ballInFlight) {
          executeThrow();
        }
      }, 300);
    }
    
    return true;
  }

  function updateBall(dt) {
    if (!activeBall) return;
    
    const speed = activeBall.speed * (dt / 1000);
    activeBall.x += activeBall.dirX * speed;
    activeBall.y += activeBall.dirY * speed;
    
    // Check collisions with obstacles
    for (const obstacle of obstacles) {
      if (activeBall.x + 10 > obstacle.x && 
          activeBall.x - 10 < obstacle.x + obstacle.width &&
          activeBall.y + 10 > obstacle.y &&
          activeBall.y - 10 < obstacle.y + obstacle.height) {
        // Ball hit an obstacle - bounce off
        // Simple bounce logic - reverse direction
        activeBall.dirX *= -1;
        activeBall.dirY *= -1;
        
        // Add some randomness to the bounce
        activeBall.dirX += (Math.random() - 0.5) * 0.2;
        activeBall.dirY += (Math.random() - 0.5) * 0.2;
        
        // Normalize direction
        const length = Math.sqrt(activeBall.dirX * activeBall.dirX + activeBall.dirY * activeBall.dirY);
        activeBall.dirX /= length;
        activeBall.dirY /= length;
        
        // Move ball outside the obstacle to prevent multiple collisions
        activeBall.x += activeBall.dirX * 15;
        activeBall.y += activeBall.dirY * 15;
      }
    }
    
    // Check collisions with dodgers
    for (let i = 0; i < dodgers.length; i++) {
      const d = dodgers[i];
      if (!d.alive || d.shielded) continue;
      
      const dx = activeBall.x - d.x;
      const dy = activeBall.y - d.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist < 26) {
        // Hit
        d.alive = false;
        resolveBall({ hitIndex: i, hit: true });
        return;
      }
    }
    
    // NEW: Check if ball passed dodgers (for scoring)
    if (mode === 'dodger') {
      const ballOwner = throwers[activeBall.ownerIndex];
      if (ballOwner && !ballOwner.isHuman) { // Only AI throwers
        dodgers.forEach((dodger, index) => {
          if (dodger.alive && !dodger.scoredOnThisBall) {
            // Check if ball has passed the dodger
            const isBallPastDodger = 
              (ballOwner.isTop && activeBall.y > dodger.y) || 
              (!ballOwner.isTop && activeBall.y < dodger.y);
            
            if (isBallPastDodger) {
              // Dodger successfully avoided the ball
              if (dodger.isHuman) {
                playerScore += 1; // Human dodger scores
              }
              dodger.scoredOnThisBall = true; // Prevent multiple scores
              updateScoreboard();
            }
          }
        });
      }
    }
    
    // Check if ball is out of bounds
    if (activeBall.x < -40 || activeBall.x > W + 40 || 
        activeBall.y < -40 || activeBall.y > H + 40) {
      resolveBall({ hit: false });
    }
  }

  function resolveBall({ hit, hitIndex }) {
    const owner = throwers[activeBall.ownerIndex];
    if (hit && owner && owner.isHuman) {
      playerScore += 1;
    }
    
    // NEW: Reset scored flags for next ball
    dodgers.forEach(d => d.scoredOnThisBall = false);
    
    activeBall = null;
    ballInFlight = false;
    
    // Rotate turn
    currentThrowerIndex = (currentThrowerIndex + 1) % throwers.length;
    updateTurnLabel();
    updateScoreboard();
    
    // If next thrower is AI, schedule their throw
    const next = throwers[currentThrowerIndex];
    if (next && !next.isHuman) {
      setTimeout(() => aiThrow(next, currentThrowerIndex), 600 + Math.random() * 700);
    }
    
    // Check game over
    const anyAlive = dodgers.some(d => d.alive);
    if (!anyAlive) endGame();
  }

  function aiThrow(aiObj, idx) {
    if (ballInFlight || idx !== currentThrowerIndex || aiObj.frozen) return;
    
    // Pick a random target (alive dodger)
    const aliveDodgers = dodgers.filter(d => d.alive && !d.shielded);
    if (aliveDodgers.length === 0) return;
    
    const target = aliveDodgers[Math.floor(Math.random() * aliveDodgers.length)];
    
    // Calculate direction to target
    const dx = target.x - aiObj.x;
    const dy = target.y - aiObj.y;
    const length = Math.sqrt(dx * dx + dy * dy);
    const dirX = dx / length;
    const dirY = dy / length;
    
    // Increase ball speed for hard difficulty in dodger mode
    const ballSpeed = (difficulty === 'hard' && mode === 'dodger') ? 500 : 400;
    
    // Create ball
    const ball = {
      id: ++ballIdCounter,
      x: aiObj.x,
      y: aiObj.y,
      dirX,
      dirY,
      speed: ballSpeed,
      ownerIndex: idx
    };
    
    activeBall = ball;
    ballInFlight = true;
    
    // If in rapid fire mode, schedule next throw
    if (aiObj.rapidFire) {
      setTimeout(() => aiThrow(aiObj, idx), 300);
    }
  }

function updateAIDodgers(dt) {
  const aliveBall = activeBall;
  const params = DIFF[difficulty];
  
  // Get thrower positions for movement boundaries
  const topThrowerY = throwers.find(t => t.isTop)?.y || 60;
  const bottomThrowerY = throwers.find(t => !t.isTop)?.y || H - 60;
  
  dodgers.forEach(d => {
    if (d.isHuman || !d.alive || d.frozen) return;
    
    let newX = d.x;
    let newY = d.y;
    
    if (!aliveBall) {
      // Idle wandering - within extended bounds
      newX += (Math.random() - 0.5) * 20 * (dt / 1000) * params.speed;
      
      // Also wander vertically within extended bounds
      newY += (Math.random() - 0.5) * 10 * (dt / 1000) * params.speed;
    } else {
      // React to ball
      const now = Date.now();
      if (now - (d.lastReact || 0) < d.reactMs) return;
      
      d.lastReact = now;
      
      if (Math.random() > d.successProb) {
        // Failed reaction - move randomly within extended bounds
        if (Math.random() > 0.6) {
          newX += (Math.random() > 0.5 ? -1 : 1) * 30 * params.speed;
        }
        if (Math.random() > 0.6) {
          newY += (Math.random() > 0.5 ? -1 : 1) * 20 * params.speed;
        }
      } else {
        // Successful dodge - strategic movement within extended bounds
        if (Math.abs(aliveBall.x - d.x) < 120) {
          const leftSpace = d.x - 30;
          const rightSpace = (W - 30) - d.x;
          const dir = rightSpace > leftSpace ? 1 : -1;
          newX += dir * (80 * params.speed);
        } else {
          newX += (W/2 - d.x) * 0.02 * params.speed;
        }
        
        // Also move vertically to avoid balls
        if (Math.abs(aliveBall.y - d.y) < 80) {
          const topSpace = d.y - (topThrowerY + 40);
          const bottomSpace = (bottomThrowerY - 40) - d.y;
          const dir = bottomSpace > topSpace ? 1 : -1;
          newY += dir * (60 * params.speed);
        }
      }
    }
    
    // Check collision before updating position
    if (!checkPlayerObstacleCollision(d, newX, newY)) {
      d.x = newX;
      d.y = newY;
    }
    
    // Constrain movement
    d.x = Math.max(30, Math.min(W - 30, d.x));
    d.y = Math.max(topThrowerY + 40, Math.min(bottomThrowerY - 40, d.y));
  });
}


  function updateAIThrowers(dt) {
    throwers.forEach((t, idx) => {
      if (t.isHuman || !t.alive || t.frozen) return;
      
      // AI throwers move randomly left and right
      if (Math.random() < 0.02) {
        t.direction = (Math.random() > 0.5) ? 1 : -1;
      }
      
      t.x += t.direction * 100 * (dt / 1000);
      
      // Constrain movement
      t.x = Math.max(30, Math.min(W - 30, t.x));
      
      // Reverse direction at edges
      if (t.x <= 30 || t.x >= W - 30) {
        t.direction *= -1;
      }
      
      // Occasionally throw balls
      if (!ballInFlight && idx === currentThrowerIndex && Math.random() < 0.01) {
        aiThrow(t, idx);
      }
    });
  }

function updateHumans(dt) {
  const speedBase = 300 * (dt / 1000);
  
  // Update human throwers
  throwers.forEach((t, idx) => {
    if (!t.isHuman || !t.alive || t.frozen) return;
    
    const set = t.control;
    let newX = t.x;
    let newY = t.y;
    
    // Calculate potential new position
    if (keyState[set.left]) newX -= speedBase * t.speedMultiplier;
    if (keyState[set.right]) newX += speedBase * t.speedMultiplier;
    
    // Check collision before updating position
    if (!checkPlayerObstacleCollision(t, newX, t.y)) {
      t.x = newX;
    }
    
    // Constrain movement based on position
    t.x = Math.max(30, Math.min(W - 30, t.x));
    
    // Aim adjustment (up/down) - no collision check needed for aiming
    const aimSpeed = 0.05;
    if (keyState[set.aimUp]) {
      if (t.isTop) {
        t.aimAngle = Math.max(Math.PI/4, Math.min(3*Math.PI/4, t.aimAngle - aimSpeed));
      } else {
        t.aimAngle = Math.max(-3*Math.PI/4, Math.min(-Math.PI/4, t.aimAngle - aimSpeed));
      }
    }
    if (keyState[set.aimDown]) {
      if (t.isTop) {
        t.aimAngle = Math.max(Math.PI/4, Math.min(3*Math.PI/4, t.aimAngle + aimSpeed));
      } else {
        t.aimAngle = Math.max(-3*Math.PI/4, Math.min(-Math.PI/4, t.aimAngle + aimSpeed));
      }
    }
    
    // Handle throw key
    if (keyState[set.throw] && idx === currentThrowerIndex && !ballInFlight) {
      if (!keyState._throwHandled) {
        startThrowGuide(t);
        keyState._throwHandled = true;
      }
    } else if (keyState._throwHandled) {
      // Throw when key is released
      executeThrow();
      keyState._throwHandled = false;
    }
    
    // Update throw guide if visible
    if (throwGuide.visible && idx === currentThrowerIndex) {
      updateThrowGuideFromAim(t);
    }
    
    // Handle abilities
    if (t.abilities) {
      t.abilities.forEach((ability, abilityIndex) => {
        if (keyState[ability.key] && !keyState[`ability_${ability.key}_handled`]) {
          if (ability.activate()) {
            updateAbilityUI();
          }
          keyState[`ability_${ability.key}_handled`] = true;
        } else if (!keyState[ability.key] && keyState[`ability_${ability.key}_handled`]) {
          keyState[`ability_${ability.key}_handled`] = false;
        }
      });
    }
  });
  
  // Update human dodgers - EXTENDED MOVEMENT AREA
  dodgers.forEach((d, idx) => {
    if (!d.isHuman || !d.alive || d.frozen) return;
    
    const set = d.control;
    if (!set) return;
    
    const sp = speedBase * d.speedMultiplier;
    let newX = d.x;
    let newY = d.y;
    
    // Calculate potential new position
    if (keyState[set.left]) newX -= sp;
    if (keyState[set.right]) newX += sp;
    if (keyState[set.up]) newY -= sp;
    if (keyState[set.down]) newY += sp;
    
    // Check collision before updating position (X movement)
    if (!checkPlayerObstacleCollision(d, newX, d.y)) {
      d.x = newX;
    } else {
      newX = d.x; // Reset X if collision detected
    }
    
    // Check collision before updating position (Y movement)
    if (!checkPlayerObstacleCollision(d, d.x, newY)) {
      d.y = newY;
    }
    
    // EXTENDED: Allow movement across the full width of the court
    d.x = Math.max(30, Math.min(W - 30, d.x));
    
    // EXTENDED: Allow vertical movement from just above bottom thrower to just below top thrower
    const topThrowerY = throwers.find(t => t.isTop)?.y || 60;
    const bottomThrowerY = throwers.find(t => !t.isTop)?.y || H - 60;
    
    d.y = Math.max(topThrowerY + 40, Math.min(bottomThrowerY - 40, d.y));
    
    // Handle abilities
    if (d.abilities) {
      d.abilities.forEach((ability, abilityIndex) => {
        if (keyState[ability.key] && !keyState[`ability_${ability.key}_handled`]) {
          if (ability.activate()) {
            updateAbilityUI();
          }
          keyState[`ability_${ability.key}_handled`] = true;
        } else if (!keyState[ability.key] && keyState[`ability_${ability.key}_handled`]) {
          keyState[`ability_${ability.key}_handled`] = false;
        }
      });
    }
  });
}

  function updateScoreboard() {
    const alive = dodgers.filter(d => d.alive).length;
    scoreboardEl.innerText = `Dodgers Remaining: ${alive} Score: ${playerScore}`;
  }

async function endGame() {
  gameRunning = false;
  
  try {
    if (localPlayer && localPlayer.id) {
      // Determine if player won or lost
      const isThrower = mode === 'thrower';
      const dodgersAlive = dodgers.filter(d => d.alive).length;
      const playerWon = (isThrower && dodgersAlive === 0) || (!isThrower && dodgersAlive > 0);
      
      const response = await fetch('/api/score', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          playerId: localPlayer.id,
          playerName: localPlayer.name, // ADD THIS LINE
          role: mode,
          difficulty,
          score: playerScore,
          result: playerWon ? 'win' : 'loss'
        })
      });
      
      const result = await response.json();
      if (!response.ok) {
        console.warn('Score submission failed:', result.error);
      } else {
        console.log('Score submitted successfully:', result.message);
      }
    }
  } catch (e) {
    console.warn('Score submission failed', e);
  }
  
  // Show game over modal
  finalScoreText.textContent = `Your score: ${playerScore}`;
  gameOverModal.classList.remove("hidden");
}

  // --- Game Loop ---
  let lastTime = performance.now();
  
  function frame(now) {
    const dt = now - lastTime;
    lastTime = now;
    
    // Clear canvas
    ctx.clearRect(0, 0, W, H);
    
    // Draw game elements
    drawCourt();
    
    if (gameRunning) {
      // Update game state
      updateHumans(dt);
      updateAIThrowers(dt);
      updateAIDodgers(dt);
      
      // Update obstacles
      obstacles.forEach(obstacle => obstacle.update(dt));
      
      updateBall(dt);
      
      // Update abilities
      const allPlayers = [...throwers, ...dodgers];
      allPlayers.forEach(player => {
        if (player.abilities) {
          player.abilities.forEach(ability => ability.update());
        }
      });
      
      // Draw entities
      throwers.forEach(t => { if (t.alive) drawHuman(t, true); });
      dodgers.forEach(d => { if (d.alive) drawHuman(d, false); });
      if (activeBall) drawBall(activeBall);
      if (throwGuide.visible) drawThrowGuide();
      
      // Update HUD
      updateScoreboard();
      updateAbilityUI();
    }
    
    requestAnimationFrame(frame);
  }

  // --- Start Game ---
  btnPlay.addEventListener('click', async () => {
    const name = playerNameInput.value.trim();
    if (!name) return alert('Please enter your name');
    
    mode = btnModeThrower.classList.contains('active') ? 'thrower' : 'dodger';
    difficulty = selectDifficulty.value || 'easy';
    humanThrowerCount = Number(selectThrowerCount.value || 1);
    humanDodgerCount = Number(selectDodgerCount.value || 1);
    
    // Create player record
    try {
      const res = await fetch('/api/start', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name })
      });
      const j = await res.json();
      localPlayer = j.player || null;
    } catch (e) {
      console.warn('Player creation error', e);
      localPlayer = { id: null, name };
    }
    
    // Hide options, show HUD and start game
    gameOptionsPage.classList.add('hidden');
    hud.classList.remove('hidden');
    buildTeams();
    gameRunning = true;
    lastTime = performance.now();
    requestAnimationFrame(frame);
  });

  // Exit to menu button
  btnExit.addEventListener('click', () => {
    gameRunning = false;
    activeBall = null;
    ballInFlight = false;
    playerScore = 0;
    hud.classList.add('hidden');
    showPage(mainMenuPage);
  });

  // Game over modal buttons
  restartBtn.addEventListener('click', () => {
    gameOverModal.classList.add('hidden');
    buildTeams();
    gameRunning = true;
    lastTime = performance.now();
    requestAnimationFrame(frame);
  });

  menuBtn.addEventListener('click', () => {
    gameOverModal.classList.add('hidden');
    hud.classList.add('hidden');
    showPage(mainMenuPage);
  });

  // Initialize
  updateScoreboard();
  updateControlsLegend();
  updateTurnLabel();

  // Start the game loop
  requestAnimationFrame(frame);

  function checkPlayerObstacleCollision(player, newX, newY) {
  const playerRadius = 20; // Approximate player collision radius
  
  for (const obstacle of obstacles) {
    // Check if the player's new position would collide with an obstacle
    const closestX = Math.max(obstacle.x, Math.min(newX, obstacle.x + obstacle.width));
    const closestY = Math.max(obstacle.y, Math.min(newY, obstacle.y + obstacle.height));
    
    const distanceX = newX - closestX;
    const distanceY = newY - closestY;
    const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
    
    if (distance < playerRadius) {
      return true; // Collision detected
    }
  }
  
  return false; // No collision
}
// Socket.IO connection
const socket = io();

// Game state with Socket.IO integration
const gameState = {
    players: [],
    balls: [],
    scores: {},
    gameStarted: false,
    playerId: null,
    playerName: '',
    role: 'dodger',
    difficulty: 'easy',
    currentPage: 'nameEntryPage',
    connectedPlayers: 0
};

// Initialize Socket.IO listeners
function initializeSocketIO() {
  socket.emit('scoreUpdate', {
  playerId: localPlayer.id,
  playerName: localPlayer.name, // ADD THIS
  role: mode,
  difficulty: difficulty,
  score: playerScore,
  result: playerWon ? 'win' : 'loss'
});
    // Connection status
    socket.on('connect', () => {
        console.log('Connected to server');
        updateConnectionStatus(true);
    });

    socket.on('disconnect', () => {
        console.log('Disconnected from server');
        updateConnectionStatus(false);
    });

    // Player count updates
    socket.on('playerCountUpdate', (count) => {
        gameState.connectedPlayers = count;
        console.log('Online players:', count);
        // You can display this in your HUD if needed
    });

    // Leaderboard updates
    socket.on('leaderboardUpdate', (leaderboardData) => {
        console.log('Leaderboard updated:', leaderboardData);
        // If leaderboard modal is open, refresh it
        if (!document.getElementById('leaderboardModal').classList.contains('hidden')) {
            showLeaderboard();
        }
    });

    // High score notifications
    socket.on('newHighScore', (highScoreData) => {
        showHighScoreNotification(highScoreData);
    });

    // Game state synchronization
    socket.on('gameStateSync', (gameData) => {
        syncGameState(gameData);
    });

    // Score update responses
    socket.on('scoreUpdateResponse', (response) => {
        handleScoreUpdateResponse(response);
    });
}

// Update connection status (you can add a small indicator to your HUD)
function updateConnectionStatus(connected) {
    const status = connected ? 'connected' : 'disconnected';
    console.log('Server status:', status);
    
    // Optional: Add a small connection indicator to your HUD
    const hud = document.getElementById('hud');
    if (hud) {
        let statusIndicator = document.getElementById('connectionStatus');
        if (!statusIndicator) {
            statusIndicator = document.createElement('div');
            statusIndicator.id = 'connectionStatus';
            statusIndicator.style.position = 'absolute';
            statusIndicator.style.top = '10px';
            statusIndicator.style.right = '10px';
            statusIndicator.style.padding = '5px 10px';
            statusIndicator.style.borderRadius = '5px';
            statusIndicator.style.fontSize = '12px';
            hud.appendChild(statusIndicator);
        }
        statusIndicator.textContent = `Server: ${status}`;
        statusIndicator.style.background = connected ? 'green' : 'red';
        statusIndicator.style.color = 'white';
    }
}

// Show high score notification
function showHighScoreNotification(highScoreData) {
    if (highScoreData.playerId === gameState.playerId) {
        // Create a temporary notification
        const notification = document.createElement('div');
        notification.style.position = 'fixed';
        notification.style.top = '50%';
        notification.style.left = '50%';
        notification.style.transform = 'translate(-50%, -50%)';
        notification.style.background = 'gold';
        notification.style.padding = '20px';
        notification.style.borderRadius = '10px';
        notification.style.zIndex = '1000';
        notification.style.fontWeight = 'bold';
        notification.style.textAlign = 'center';
        notification.innerHTML = `
            🎉 NEW HIGH SCORE!<br>
            ${highScoreData.score} points as ${highScoreData.role}<br>
            Difficulty: ${highScoreData.difficulty}
        `;
        
        document.body.appendChild(notification);
        
        setTimeout(() => {
            document.body.removeChild(notification);
        }, 5000);
    }
}

// Synchronize game state from server
function syncGameState(gameData) {
    // Merge server game state with local state for multiplayer synchronization
    if (gameData.players) {
        gameState.players = gameData.players;
    }
    if (gameData.balls) {
        gameState.balls = gameData.balls;
    }
    if (gameData.scores) {
        gameState.scores = gameData.scores;
    }
}

// Handle score update response
function handleScoreUpdateResponse(response) {
    if (response.ok) {
        console.log('Score updated successfully via socket');
    } else {
        console.error('Score update failed:', response.error);
    }
}

// Modified registerPlayer function with Socket.IO integration
async function registerPlayer(name) {
    try {
        const response = await fetch('/api/start', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ name })
        });

        if (response.ok) {
            const data = await response.json();
            gameState.playerId = data.player.id;
            gameState.playerName = data.player.name;
            
            // Initialize Socket.IO after successful registration
            initializeSocketIO();
            
            return true;
        } else {
            throw new Error('Registration failed');
        }
    } catch (error) {
        console.error('Registration error:', error);
        return false;
    }
}

// Modified updateScore function with Socket.IO integration
async function updateScore(score, result = null) {
  if (!gameState.playerId) return;

  const scoreData = {
    playerId: gameState.playerId,
    playerName: gameState.playerName, // ADD THIS LINE
    role: gameState.role,
    difficulty: gameState.difficulty,
    score: score,
    result: result
  };

  try {
    // Use REST API for score updates
    const response = await fetch('/api/score', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(scoreData)
    });

    if (response.ok) {
      const result = await response.json();
      console.log('Score updated:', result);
      return result;
    }
  } catch (error) {
    console.error('Score update error:', error);
  }
}

// Modified showLeaderboard function with real-time updates
async function showLeaderboard() {
    try {
        const role = gameState.role;
        const difficulty = gameState.difficulty;
        const response = await fetch(`/api/leaderboard?role=${role}&difficulty=${difficulty}&limit=10`);
        
        if (response.ok) {
            const leaderboardData = await response.json();
            displayLeaderboard(leaderboardData);
        }
    } catch (error) {
        console.error('Leaderboard load error:', error);
    }
}

// Enhanced displayLeaderboard function
// Enhanced displayLeaderboard function
function displayLeaderboard(leaderboardData) {
  const content = document.getElementById('leaderboardContent');
  if (!content) return;

  let html = '<table style="width:100%;border-collapse:collapse;margin:10px 0">';
  html += `
      <tr style="background:#f0f0f0">
          <th style="padding:8px;text-align:left">Rank</th>
          <th style="padding:8px;text-align:left">Player</th>
          <th style="padding:8px;text-align:center">Score</th>
          <th style="padding:8px;text-align:center">Wins</th>
          <th style="padding:8px;text-align:center">Games</th>
      </tr>
  `;
  
  leaderboardData.forEach((player, index) => {
      const isCurrentPlayer = player.player_id === gameState.playerId;
      const rowStyle = isCurrentPlayer ? 'background-color:#e6f7ff;font-weight:bold' : '';
      
      html += `
          <tr style="${rowStyle}">
              <td style="padding:8px;border-bottom:1px solid #ddd">${index + 1}</td>
              <td style="padding:8px;border-bottom:1px solid #ddd">${player.player_name || player.name}</td> <!-- UPDATE THIS LINE -->
              <td style="padding:8px;border-bottom:1px solid #ddd;text-align:center">${player.total_score}</td>
              <td style="padding:8px;border-bottom:1px solid #ddd;text-align:center">${player.wins}</td>
              <td style="padding:8px;border-bottom:1px solid #ddd;text-align:center">${player.games_played}</td>
          </tr>
      `;
  });
  
  html += '</table>';
  content.innerHTML = html;
}

// Enhanced game over function with score submission
function showGameOver(finalScore, result) {
    // Update score on server
    updateScore(finalScore, result).then(serverResponse => {
        const finalScoreText = document.getElementById('finalScoreText');
        if (finalScoreText) {
            let text = `Your score: ${finalScore}`;
            if (serverResponse && serverResponse.newHighScore) {
                text += ' 🎉 NEW HIGH SCORE!';
            }
            finalScoreText.textContent = text;
        }
    });

    // Show game over modal
    document.getElementById('gameOverModal').classList.remove('hidden');
}

// Multiplayer game state synchronization
function broadcastGameState() {
    if (!gameState.gameStarted) return;

    const gameData = {
        players: gameState.players,
        balls: gameState.balls,
        scores: gameState.scores,
        timestamp: Date.now()
    };

    socket.emit('gameStateUpdate', gameData);
}

// Add this to your existing game loop
function gameLoop() {
    // Your existing game logic here...
    
    // Broadcast game state for multiplayer synchronization
    if (gameState.gameStarted) {
        broadcastGameState();
    }
    
    // Continue the game loop
    requestAnimationFrame(gameLoop);
}

// Initialize when the page loads
document.addEventListener('DOMContentLoaded', function() {
    // Your existing initialization code...
    
    // Add Socket.IO initialization after player registration
    const originalContinueHandler = function() {
        const name = document.getElementById('playerName').value.trim();
        if (!name) {
            document.getElementById('nameError').classList.remove('hidden');
            return;
        }
        
        registerPlayer(name).then(success => {
            if (success) {
                // Your existing page navigation code...
                showPage('mainMenuPage');
            } else {
                alert('Failed to register player. Please try again.');
            }
        });
    };
    
    // Replace the existing continue button handler
    document.getElementById('btnContinue').addEventListener('click', originalContinueHandler);
});
})();
  </script>
  <script src="socket.io/socket.io.js"></script>
</body>
</html>
